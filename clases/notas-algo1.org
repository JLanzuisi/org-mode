#+TITLE: Resumen de los contenidos del curso.
#+SUBTITLE: Notas para estudiar.
#+AUTHOR: Jhonny Lanzuisi
#+EMAIL: jalb97@gmail.com
#+TAGS: :uni:algo1:
#+GROFF_CLASS:
#+LANGUAGE: es

# ----LICENSE----
#  Copyright 2021 Jhonny Lanzuisi (jalb97@gmail.com)
#  More source files at github.com/JLanzuisi
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
# ---------------

* Prop\*[']osito, libros utilizados y otras cosas
Mi idea e \*[']s una suerte de "resumen" de los contenidos.
Algunas veces simplemente copio y pego de los autores,
otras cambio como algo esta escrito para, por ejemplo,
hacer la notación uniforme o explicar algo de forma mas clara.

Las referencias principales son el Kaldewaij ,
y el ravelo .
Puede que aparezca algo sacado de internet,
en cuyo caso se indicará la fuente en ese momento.

* Técnicas para hallar invariantes

Conviene tener en cuenta los siguientes pasos:

1. Determinar el Invariante y las guardias.
2. Inicialización: Establecer el invariante la primera vez. Es decir, establecer el valor
   inicial de las variables para que se cumpla el invariante.
3. Determinar la función de cota a partir de (1) y (2).
4. Desarrollar el trozo de programa que corresponde al cuerpo de cada guardia de manera
   que cumpla la especificación:
   \[\tripleta{\text{Invariante y Guardia}}{S}{\text{Invariante}}\]
   Este paso se
   puede descomponer en primero modificar la función de cota como última instrucción de
   \(S\) y en función de esto desarrollar el resto de \(S\). La modificación de la función de cota es
   la que garantiza que la función decrece (o crece) estrictamente.

** Eliminar un predicado de una conjunción



#+BEGIN_SRC pascal -n
|[
const A, B: entero;
var q, r: entero;

{ A >= 0 /\ B > 0 }

divmod

{ q = A div B /\ r = A mod B }
]|
#+END_SRC

* Técnicas generales para invariantes en iteraciones

** Tomar conjunciones como invariantes
Cuando la especificación de un programa
termina con una poscondición formada por dos conjunciones,
esta técnica sugiere tomar una de ellas como invariante
y la otra como negación de la guardia,
es decir,
la conjunción que no se tomó como invariante se niega
y eso es lo que se utiliza como guardia para el =do=.

Como un ejemplo de esta técnica se considera el programa
siguiente, que calcula el entero inmediatamente anterior
a la raiz cuadrada de un entero =N=.

#+BEGIN_SRC pascal
const N: int;
var x: int;

{N >= 0}

<squareroot>

{x^2 <= N /\ (x+1)^2 > N}
#+END_SRC

Una solución posible al finalizar es:

#+BEGIN_SRC pascal
const N: int;
var x: int;

{N >= 0}
x := N

{Invariante P: 0 <= x /\ (x+1)^2 > N}
{Cota: x}

;do x * x > N -->
    x := x - 1
od

{x^2 <= N /\ (x+1)^2 > N}
#+END_SRC
** Reemplazar constantes por variables

** Fortalecer los invariantes
